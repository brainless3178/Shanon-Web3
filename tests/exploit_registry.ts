// =============================================================================
// Exploit Registry Integration Tests
// =============================================================================
//
// Tests the on-chain exploit registry for:
//   1. Registry initialization
//   2. Exploit finding registration (with fixed seeds constraint)
//   3. Audit summary registration
//   4. Config account PDA validation (seeds = [b"config"], bump)
//
// Run with: anchor test
//
// =============================================================================

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";

describe("exploit-registry", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.ExploitRegistry as Program;
  const admin = provider.wallet;

  const [configPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("config")],
    program.programId
  );

  it("Initializes the registry", async () => {
    const tx = await program.methods
      .initialize()
      .accounts({
        config: configPda,
        admin: admin.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    const config = await program.account.registryConfig.fetch(configPda);
    expect(config.admin.toString()).to.equal(admin.publicKey.toString());
    expect(config.totalReports.toNumber()).to.equal(0);
    expect(config.totalAudits.toNumber()).to.equal(0);
    expect(config.isFrozen).to.equal(false);
    console.log("  ✅ Registry initialized, admin:", admin.publicKey.toString().substring(0, 16) + "...");
  });

  it("Registers an exploit finding (SOL-019: First-Depositor)", async () => {
    const targetProgram = Keypair.generate();
    const vulnerabilityType = "first_depositor_attack";
    const severity = 4; // Critical
    const proofHash = Buffer.alloc(32);
    proofHash.write("deadbeef", "hex");
    const metadataUrl = "https://audit.solana-security-swarm.dev/finding/SOL-019";

    const [exploitPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("exploit"),
        targetProgram.publicKey.toBuffer(),
        Buffer.from(vulnerabilityType),
      ],
      program.programId
    );

    await program.methods
      .registerExploit(
        vulnerabilityType,
        severity,
        Array.from(proofHash),
        metadataUrl
      )
      .accounts({
        exploitProfile: exploitPda,
        config: configPda, // Now uses seeds=[b"config"], bump
        targetProgram: targetProgram.publicKey,
        reporter: admin.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    const profile = await program.account.exploitProfile.fetch(exploitPda);
    expect(profile.programId.toString()).to.equal(targetProgram.publicKey.toString());
    expect(profile.reporter.toString()).to.equal(admin.publicKey.toString());
    expect(profile.severity).to.equal(severity);
    expect(profile.vulnerabilityType).to.equal(vulnerabilityType);
    expect(profile.metadataUrl).to.equal(metadataUrl);
    expect(profile.timestamp.toNumber()).to.be.greaterThan(0);

    const config = await program.account.registryConfig.fetch(configPda);
    expect(config.totalReports.toNumber()).to.equal(1);
    console.log("  ✅ Exploit SOL-019 registered, total_reports:", config.totalReports.toNumber());
  });

  it("Registers a second exploit (SOL-001: Missing ACL)", async () => {
    const targetProgram = Keypair.generate();
    const vulnerabilityType = "missing_access_control";
    const severity = 3; // High
    const proofHash = Buffer.alloc(32);
    proofHash.write("cafebabe", "hex");
    const metadataUrl = "https://audit.solana-security-swarm.dev/finding/SOL-001";

    const [exploitPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("exploit"),
        targetProgram.publicKey.toBuffer(),
        Buffer.from(vulnerabilityType),
      ],
      program.programId
    );

    await program.methods
      .registerExploit(
        vulnerabilityType,
        severity,
        Array.from(proofHash),
        metadataUrl
      )
      .accounts({
        exploitProfile: exploitPda,
        config: configPda,
        targetProgram: targetProgram.publicKey,
        reporter: admin.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    const config = await program.account.registryConfig.fetch(configPda);
    expect(config.totalReports.toNumber()).to.equal(2);
    console.log("  ✅ Exploit SOL-001 registered, total_reports:", config.totalReports.toNumber());
  });

  it("Registers an audit summary", async () => {
    const targetProgram = Keypair.generate();
    const reportHash = Buffer.alloc(32);
    reportHash.write("baadbeef", "hex");

    const [auditPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("audit"),
        targetProgram.publicKey.toBuffer(),
        admin.publicKey.toBuffer(),
      ],
      program.programId
    );

    await program.methods
      .registerAudit(
        13, // findings_count
        3,  // critical
        4,  // high
        4,  // medium
        2,  // low
        68, // security_score
        Array.from(reportHash),
        "https://audit.solana-security-swarm.dev/report/001"
      )
      .accounts({
        auditSummary: auditPda,
        config: configPda,
        targetProgram: targetProgram.publicKey,
        auditor: admin.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    const summary = await program.account.auditSummary.fetch(auditPda);
    expect(summary.programId.toString()).to.equal(targetProgram.publicKey.toString());
    expect(summary.findingsCount).to.equal(13);
    expect(summary.criticalCount).to.equal(3);
    expect(summary.highCount).to.equal(4);
    expect(summary.securityScore).to.equal(68);
    expect(summary.reportUrl).to.equal("https://audit.solana-security-swarm.dev/report/001");

    const config = await program.account.registryConfig.fetch(configPda);
    expect(config.totalAudits.toNumber()).to.equal(1);
    console.log("  ✅ Audit registered, score:", summary.securityScore, "total_audits:", config.totalAudits.toNumber());
  });

  it("Rejects fake config account (seeds constraint enforced)", async () => {
    const targetProgram = Keypair.generate();
    const vulnerabilityType = "test_fake_config";
    const fakeConfig = Keypair.generate();

    const [exploitPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("exploit"),
        targetProgram.publicKey.toBuffer(),
        Buffer.from(vulnerabilityType),
      ],
      program.programId
    );

    let failed = false;
    try {
      await program.methods
        .registerExploit(
          vulnerabilityType,
          4,
          Array.from(Buffer.alloc(32)),
          "https://fake.example.com"
        )
        .accounts({
          exploitProfile: exploitPda,
          config: fakeConfig.publicKey, // FAKE config — should be rejected
          targetProgram: targetProgram.publicKey,
          reporter: admin.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();
    } catch (err) {
      failed = true;
      console.log("  ✅ Fake config account rejected:", (err as Error).message.substring(0, 80));
    }

    expect(failed).to.equal(true, "Fake config account must be rejected by seeds constraint");
  });

  after(() => {
    console.log("");
    console.log("═".repeat(60));
    console.log("Exploit Registry Test Suite Complete");
    console.log("═".repeat(60));
  });
});
