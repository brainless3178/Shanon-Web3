// =============================================================================
// Vulnerability Comparison Tests
// =============================================================================
//
// Side-by-side comparison of vulnerable-vault vs security_shield
// to prove the scanner's findings are real.
//
// Run with: anchor test
//
// =============================================================================

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { SecurityShield } from "../../target/types/security_shield";
import { VulnerableVault } from "../../target/types/vulnerable_vault";
import { Keypair, LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, createMint, createAccount, mintTo, getAccount } from "@solana/spl-token";
import { expect } from "chai";

describe("Vulnerability Comparison: VulnerableVault vs SecurityShield", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const secureProgram = anchor.workspace.SecurityShield as Program<SecurityShield>;
    const vulnProgram = anchor.workspace.VulnerableVault as Program<VulnerableVault>;

    let mint: PublicKey;
    let admin = Keypair.generate();
    let attacker = Keypair.generate();

    // Secure program PDAs
    const [secureVaultPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("vault")], secureProgram.programId
    );
    const [secureEmergencyPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("emergency_state")], secureProgram.programId
    );

    // Vulnerable program PDAs
    const [vulnVaultPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("vault")], vulnProgram.programId
    );
    const [vulnEmergencyPda] = PublicKey.findProgramAddressSync(
        [Buffer.from("emergency_state")], vulnProgram.programId
    );

    let secureAdminToken: PublicKey;
    let secureVaultToken: PublicKey;
    let vulnAdminToken: PublicKey;
    let vulnVaultToken: PublicKey;

    before(async () => {
        for (const kp of [admin, attacker]) {
            const sig = await provider.connection.requestAirdrop(kp.publicKey, 10 * LAMPORTS_PER_SOL);
            const lbh = await provider.connection.getLatestBlockhash();
            await provider.connection.confirmTransaction({ signature: sig, ...lbh });
        }

        mint = await createMint(
            provider.connection,
            (provider.wallet as any).payer,
            provider.wallet.publicKey,
            null, 9
        );

        // Token accounts for secure program
        secureVaultToken = await createAccount(provider.connection, (provider.wallet as any).payer, mint, secureVaultPda, undefined, { skipPreflight: true });
        secureAdminToken = await createAccount(provider.connection, (provider.wallet as any).payer, mint, admin.publicKey);

        // Token accounts for vulnerable program
        vulnVaultToken = await createAccount(provider.connection, (provider.wallet as any).payer, mint, vulnVaultPda, Keypair.generate(), { skipPreflight: true });
        vulnAdminToken = await createAccount(provider.connection, (provider.wallet as any).payer, mint, admin.publicKey, Keypair.generate());

        // Mint tokens
        await mintTo(provider.connection, (provider.wallet as any).payer, mint, secureAdminToken, provider.wallet.publicKey, 5_000_000_000);
        await mintTo(provider.connection, (provider.wallet as any).payer, mint, vulnAdminToken, provider.wallet.publicKey, 5_000_000_000);

        console.log("╔══════════════════════════════════════════════════╗");
        console.log("║  Vulnerability Comparison Test Suite             ║");
        console.log("║  Proving scanner findings are real               ║");
        console.log("╚══════════════════════════════════════════════════╝");
    });

    describe("SOL-019: First-Depositor Guard", () => {
        it("SETUP: Initialize both vaults", async () => {
            await secureProgram.methods.initializeVault()
                .accounts({ vault: secureVaultPda, admin: admin.publicKey, mint, systemProgram: anchor.web3.SystemProgram.programId })
                .signers([admin]).rpc();

            await vulnProgram.methods.initializeVault()
                .accounts({ vault: vulnVaultPda, admin: admin.publicKey, mint, systemProgram: anchor.web3.SystemProgram.programId })
                .signers([admin]).rpc();
        });

        it("VULNERABLE: 1-lamport deposit accepted (attack start)", async () => {
            const [sharesPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("user_shares"), admin.publicKey.toBuffer()], vulnProgram.programId
            );
            await vulnProgram.methods.initializeUserShares()
                .accounts({ userShares: sharesPda, user: admin.publicKey, systemProgram: anchor.web3.SystemProgram.programId })
                .signers([admin]).rpc();

            await vulnProgram.methods.deposit(new anchor.BN(1))
                .accounts({ vault: vulnVaultPda, userShares: sharesPda, userToken: vulnAdminToken, vaultToken: vulnVaultToken, user: admin.publicKey, tokenProgram: TOKEN_PROGRAM_ID })
                .signers([admin]).rpc();

            const shares = await vulnProgram.account.userShares.fetch(sharesPda);
            expect(shares.shares.toNumber()).to.equal(1);
            console.log("  ⚠️  VULN: 1-lamport deposit → 1 share (attack enabled)");
        });

        it("SECURE: 1-lamport deposit rejected", async () => {
            const [sharesPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("user_shares"), admin.publicKey.toBuffer()], secureProgram.programId
            );
            await secureProgram.methods.initializeUserShares()
                .accounts({ userShares: sharesPda, user: admin.publicKey, systemProgram: anchor.web3.SystemProgram.programId })
                .signers([admin]).rpc();

            let failed = false;
            try {
                await secureProgram.methods.deposit(new anchor.BN(1))
                    .accounts({ vault: secureVaultPda, userShares: sharesPda, userToken: secureAdminToken, vaultToken: secureVaultToken, user: admin.publicKey, tokenProgram: TOKEN_PROGRAM_ID })
                    .signers([admin]).rpc();
            } catch { failed = true; }

            expect(failed).to.equal(true);
            console.log("  ✅ SECURE: 1-lamport deposit rejected (MIN_FIRST_DEPOSIT)");
        });
    });

    describe("SOL-001: Emergency Pause ACL", () => {
        it("SETUP: Initialize emergency state on both", async () => {
            await secureProgram.methods.initializeEmergencyState()
                .accounts({ emergencyState: secureEmergencyPda, admin: admin.publicKey, systemProgram: anchor.web3.SystemProgram.programId })
                .signers([admin]).rpc();

            await vulnProgram.methods.initializeEmergencyState()
                .accounts({ emergencyState: vulnEmergencyPda, admin: admin.publicKey, systemProgram: anchor.web3.SystemProgram.programId })
                .signers([admin]).rpc();
        });

        it("VULNERABLE: Non-admin can pause", async () => {
            await vulnProgram.methods.emergencyPause("griefing!", new anchor.BN(3600))
                .accounts({ emergencyState: vulnEmergencyPda, caller: attacker.publicKey })
                .signers([attacker]).rpc();

            const state = await vulnProgram.account.emergencyState.fetch(vulnEmergencyPda);
            expect(state.isPaused).to.equal(true);
            console.log("  ⚠️  VULN: Attacker paused the protocol!");
        });

        it("SECURE: Non-admin pause rejected", async () => {
            let failed = false;
            try {
                await secureProgram.methods.emergencyPause("griefing!", new anchor.BN(3600))
                    .accounts({ emergencyState: secureEmergencyPda, caller: attacker.publicKey })
                    .signers([attacker]).rpc();
            } catch { failed = true; }

            expect(failed).to.equal(true);
            console.log("  ✅ SECURE: Non-admin pause rejected (admin-only)");
        });
    });

    after(() => {
        console.log("");
        console.log("═".repeat(60));
        console.log("Vulnerability Comparison Complete");
        console.log("Scanner findings SOL-019 and SOL-001 confirmed on-chain.");
        console.log("═".repeat(60));
    });
});
