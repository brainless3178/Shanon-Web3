use anchor_lang::prelude::*;
pub mod state;
use crate::state::*;

declare_id!("4cb3bZbBbXUxX6Ky4FFsEZEUBPe4TaRhvBEyuV9En6Zq");

#[program]
pub mod exploit_registry {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let config = &mut ctx.accounts.config;
        config.admin = ctx.accounts.admin.key();
        config.total_reports = 0;
        config.total_audits = 0;
        config.is_frozen = false;
        config.bump = ctx.bumps.config;
        Ok(())
    }

    pub fn set_frozen(ctx: Context<AdminOnly>, frozen: bool) -> Result<()> {
        let config = &mut ctx.accounts.config;
        config.is_frozen = frozen;
        emit!(RegistryFrozenEvent { frozen, timestamp: Clock::get()?.unix_timestamp });
        Ok(())
    }

    pub fn update_admin(ctx: Context<AdminOnly>, new_admin: Pubkey) -> Result<()> {
        let config = &mut ctx.accounts.config;
        let old_admin = config.admin;
        config.admin = new_admin;
        emit!(AdminUpdatedEvent { old_admin, new_admin, timestamp: Clock::get()?.unix_timestamp });
        Ok(())
    }

    pub fn register_exploit(
        ctx: Context<RegisterExploit>,
        vulnerability_type: String,
        severity: u8,
        proof_hash: [u8; 32],
        metadata_url: String,
    ) -> Result<()> {
        let config = &mut ctx.accounts.config;
        require!(!config.is_frozen, ErrorCode::RegistryFrozen);

        // Validation
        require!(vulnerability_type.len() <= 64, ErrorCode::StringTooLong);
        require!(metadata_url.len() <= 128, ErrorCode::StringTooLong);
        require!(severity > 0 && severity <= 10, ErrorCode::InvalidSeverity);

        let profile = &mut ctx.accounts.exploit_profile;

        profile.program_id = ctx.accounts.target_program.key();
        profile.reporter = ctx.accounts.reporter.key();
        profile.timestamp = Clock::get()?.unix_timestamp;
        profile.severity = severity;
        profile.vulnerability_type = vulnerability_type;
        profile.proof_hash = proof_hash;
        profile.metadata_url = metadata_url;
        profile.bump = ctx.bumps.exploit_profile;

        config.total_reports = config.total_reports.checked_add(1).ok_or(ErrorCode::Overflow)?;

        emit!(ExploitRegisteredEvent {
            target: ctx.accounts.target_program.key(),
            reporter: ctx.accounts.reporter.key(),
            severity,
        });

        Ok(())
    }

    pub fn register_audit(
        ctx: Context<RegisterAudit>,
        findings_count: u32,
        critical_count: u32,
        high_count: u32,
        medium_count: u32,
        low_count: u32,
        security_score: u8,
        report_hash: [u8; 32],
        report_url: String,
    ) -> Result<()> {
        let config = &mut ctx.accounts.config;
        require!(!config.is_frozen, ErrorCode::RegistryFrozen);

        // Validation
        require!(report_url.len() <= 128, ErrorCode::StringTooLong);
        require!(security_score <= 100, ErrorCode::InvalidScore);

        let summary = &mut ctx.accounts.audit_summary;

        // Only increment count on first audit (not re-audits via init_if_needed)
        if summary.timestamp == 0 {
            config.total_audits = config.total_audits.checked_add(1).ok_or(ErrorCode::Overflow)?;
        }

        summary.program_id = ctx.accounts.target_program.key();
        summary.auditor = ctx.accounts.auditor.key();
        summary.timestamp = Clock::get()?.unix_timestamp;
        summary.findings_count = findings_count;
        summary.critical_count = critical_count;
        summary.high_count = high_count;
        summary.medium_count = medium_count;
        summary.low_count = low_count;
        summary.security_score = security_score;
        summary.report_hash = report_hash;
        summary.report_url = report_url;
        summary.bump = ctx.bumps.audit_summary;

        emit!(AuditRegisteredEvent {
            target: ctx.accounts.target_program.key(),
            auditor: ctx.accounts.auditor.key(),
            score: security_score,
        });

        Ok(())
    }
}

#[derive(Accounts)]
pub struct AdminOnly<'info> {
    #[account(mut, seeds = [b"config"], bump = config.bump, has_one = admin @ ErrorCode::Unauthorized)]
    pub config: Account<'info, RegistryConfig>,
    pub admin: Signer<'info>,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = admin,
        space = 8 + RegistryConfig::SIZE,
        seeds = [b"config"],
        bump
    )]
    pub config: Account<'info, RegistryConfig>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(vulnerability_type: String)]
pub struct RegisterExploit<'info> {
    #[account(
        init,
        payer = reporter,
        space = 8 + ExploitProfile::SIZE,
        seeds = [b"exploit", target_program.key().as_ref(), vulnerability_type.as_bytes()],
        bump
    )]
    pub exploit_profile: Account<'info, ExploitProfile>,
    #[account(mut, seeds = [b"config"], bump = config.bump)]
    pub config: Account<'info, RegistryConfig>,
    /// CHECK: Target program being reported â€” any valid pubkey is accepted
    pub target_program: UncheckedAccount<'info>,
    #[account(mut)]
    pub reporter: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RegisterAudit<'info> {
    #[account(
        init_if_needed,
        payer = auditor,
        space = 8 + AuditSummary::SIZE,
        seeds = [b"audit", target_program.key().as_ref(), auditor.key().as_ref()],
        bump
    )]
    pub audit_summary: Account<'info, AuditSummary>,
    #[account(mut, seeds = [b"config"], bump = config.bump)]
    pub config: Account<'info, RegistryConfig>,
    /// CHECK: Target program being audited
    pub target_program: UncheckedAccount<'info>,
    #[account(mut)]
    pub auditor: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[event]
pub struct AdminUpdatedEvent {
    pub old_admin: Pubkey,
    pub new_admin: Pubkey,
    pub timestamp: i64,
}

#[event]
pub struct RegistryFrozenEvent {
    pub frozen: bool,
    pub timestamp: i64,
}

#[event]
pub struct ExploitRegisteredEvent {
    pub target: Pubkey,
    pub reporter: Pubkey,
    pub severity: u8,
}

#[event]
pub struct AuditRegisteredEvent {
    pub target: Pubkey,
    pub auditor: Pubkey,
    pub score: u8,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Registry is currently frozen")]
    RegistryFrozen,
    #[msg("Unauthorized access")]
    Unauthorized,
    #[msg("String input is too long")]
    StringTooLong,
    #[msg("Invalid severity (must be 1-10)")]
    InvalidSeverity,
    #[msg("Invalid security score (must be 0-100)")]
    InvalidScore,
    #[msg("Arithmetic overflow")]
    Overflow,
}
